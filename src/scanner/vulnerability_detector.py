"""
Vulnerability Detection Module
Identifies specific vulnerability types and their exact locations in code
"""

import re
from typing import List, Dict, Tuple

# Comprehensive vulnerability pattern definitions
VULNERABILITY_PATTERNS = {
    'SQL_INJECTION': {
        'patterns': {
            'py': [
                r'cursor\.execute\s*\(\s*query\s*\)',  # cursor.execute(query) - where query is built with concatenation
                r'cursor\.execute\s*\(\s*["\'].*["\'].*%',  # cursor.execute("..." % ...)
                r'\.execute\s*\(\s*.*\.format\(',  # .execute(query.format(...))
                r'\.execute\s*\(\s*f["\'].*SELECT',  # .execute(f"SELECT ...")
                r'\.execute\s*\(\s*f["\'].*INSERT',  # .execute(f"INSERT ...")
                r'\.execute\s*\(\s*f["\'].*UPDATE',  # .execute(f"UPDATE ...")
                r'\.execute\s*\(\s*["\'][^"\']*["\'].*%.*\(',  # .execute("..." % (...))
                r'\.raw\s*\(\s*["\'].*%',  # .raw("... %s" % ...)
            ],
            'js': [
                r'\.query\s*\([^)]*\+[^)]*\)',
                r'\.execute\s*\([^)]*\+[^)]*\)',
                r'SELECT.*\+.*FROM',
                r'INSERT.*\+.*INTO',
                r'UPDATE.*\+.*SET',
            ],
            'java': [
                r'Statement\s+\w+\s*=.*createStatement',
                r'\.executeQuery\s*\([^)]*\+[^)]*\)',
                r'\.executeUpdate\s*\([^)]*\+[^)]*\)',
                r'createStatement\(\)\.execute',
            ]
        },
        'description': 'SQL Injection vulnerability detected. User input is directly concatenated into SQL queries.',
        'severity': 'HIGH',
        'recommendation': 'Use parameterized queries or prepared statements.'
    },
    
    'XSS': {
        'patterns': {
            'py': [
                r'\.write\s*\([^)]*request\.',
                r'HttpResponse\s*\([^)]*request\.',
                r'render_template_string\s*\(\s*["\'].*<.*\{',  # render_template_string with HTML and variables
                r'render_template_string\s*\(\s*f["\'].*<',  # render_template_string with f-string HTML
                r'["\'].*<.*["\'].*\+.*request\.',  # HTML string concatenation with request
                r'f["\']<.*\{.*request\.',  # f-string HTML with request data
            ],
            'js': [
                r'\.innerHTML\s*=\s*.*',
                r'document\.write\s*\(',
                r'\.outerHTML\s*=',
                r'\.insertAdjacentHTML\s*\(',
                r'dangerouslySetInnerHTML',
                r'\.html\s*\([^)]*\$',
            ],
            'java': [
                r'\.print\s*\([^)]*request\.getParameter',
                r'\.println\s*\([^)]*request\.getParameter',
                r'\.append\s*\([^)]*request\.getParameter',
            ]
        },
        'description': 'Cross-Site Scripting (XSS) vulnerability. User input is rendered without proper sanitization.',
        'severity': 'HIGH',
        'recommendation': 'Sanitize and escape user input before rendering. Use safe APIs like textContent or innerText.'
    },
    
    'COMMAND_INJECTION': {
        'patterns': {
            'py': [
                r'os\.system\s*\([^)]*input',
                r'os\.system\s*\([^)]*request',
                r'subprocess\.call\s*\([^)]*shell\s*=\s*True',
                r'subprocess\.Popen\s*\([^)]*shell\s*=\s*True',
                r'os\.popen\s*\(',
                r'commands\.getoutput\s*\(',
            ],
            'js': [
                r'child_process\.exec\s*\([^)]*req\.',
                r'\.exec\s*\([^)]*process\.argv',
                r'spawn\s*\([^)]*shell\s*:\s*true',
            ],
            'java': [
                r'Runtime\.getRuntime\(\)\.exec\s*\([^)]*request',
                r'ProcessBuilder\s*\([^)]*request',
                r'\.exec\s*\([^)]*getParameter',
            ]
        },
        'description': 'Command Injection vulnerability. User input is executed as system commands.',
        'severity': 'CRITICAL',
        'recommendation': 'Avoid executing system commands with user input. Use safe APIs and validate input strictly.'
    },
    
    'PATH_TRAVERSAL': {
        'patterns': {
            'py': [
                r'open\s*\([^)]*request\.',
                r'open\s*\(\s*[^,)]*(?:filename|filepath|path|file)[^,)]*[,)]',  # open with file-related variables
                r'\.read\s*\([^)]*request\.',
                r'os\.path\.join\s*\([^)]*request\.',
                r'os\.path\.join\s*\([^)]*filename',  # os.path.join with filename variable
                r'Path\s*\([^)]*request\.',
            ],
            'js': [
                r'fs\.readFile\s*\([^)]*req\.',
                r'fs\.readFileSync\s*\([^)]*req\.',
                r'require\s*\([^)]*req\.',
                r'path\.join\s*\([^)]*req\.',
            ],
            'java': [
                r'new\s+File\s*\([^)]*request\.getParameter',
                r'FileInputStream\s*\([^)]*request',
                r'\.readFile\s*\([^)]*request',
            ]
        },
        'description': 'Path Traversal vulnerability. User input controls file paths without validation.',
        'severity': 'HIGH',
        'recommendation': 'Validate and sanitize file paths. Use whitelist approach for allowed paths.'
    },
    
    'CODE_INJECTION': {
        'patterns': {
            'py': [
                r'\beval\s*\(',
                r'\bexec\s*\(',
                r'(?<!re\.)(?<!regex\.)compile\s*\([^)]*\+',  # compile with concatenation, but not re.compile
                r'__import__\s*\(',
                r'execfile\s*\(',
            ],
            'js': [
                r'\beval\s*\(',
                r'Function\s*\(',
                r'setTimeout\s*\([^)]*["\'].*\+',
                r'setInterval\s*\([^)]*["\'].*\+',
            ],
            'java': [
                r'ScriptEngineManager',
                r'\.eval\s*\(',
                r'Class\.forName\s*\([^)]*request',
                r'\.newInstance\s*\(',
            ]
        },
        'description': 'Code Injection vulnerability. Dynamic code execution with untrusted input.',
        'severity': 'CRITICAL',
        'recommendation': 'Never use eval() or exec() with user input. Use safe alternatives.'
    },
    
    'DESERIALIZATION': {
        'patterns': {
            'py': [
                r'pickle\.loads\s*\(',
                r'pickle\.load\s*\([^)]*request',
                r'yaml\.load\s*\([^)]*Loader\s*=\s*yaml\.Loader',
                r'marshal\.loads\s*\(',
            ],
            'js': [
                r'eval\s*\(\s*JSON\.parse',
                r'JSON\.parse\s*\([^)]*req\.',
                r'unserialize\s*\(',
            ],
            'java': [
                r'ObjectInputStream\s*\([^)]*request',
                r'readObject\s*\(',
                r'XMLDecoder\s*\(',
            ]
        },
        'description': 'Insecure Deserialization. Untrusted data is deserialized without validation.',
        'severity': 'CRITICAL',
        'recommendation': 'Avoid deserializing untrusted data. Use safe serialization formats like JSON.'
    },
    
    'WEAK_CRYPTO': {
        'patterns': {
            'py': [
                r'md5\(',
                r'sha1\(',
                r'hashlib\.md5',
                r'hashlib\.sha1',
                r'random\.random\(',
            ],
            'js': [
                r'Math\.random\(\)',
                r'crypto\.createHash\(["\']md5',
                r'crypto\.createHash\(["\']sha1',
            ],
            'java': [
                r'MessageDigest\.getInstance\(["\']MD5',
                r'MessageDigest\.getInstance\(["\']SHA-1',
                r'Random\(\)',
            ]
        },
        'description': 'Weak cryptographic algorithm usage. MD5, SHA1, or weak random number generation.',
        'severity': 'MEDIUM',
        'recommendation': 'Use strong cryptographic algorithms like SHA-256, SHA-3, or bcrypt. Use cryptographically secure random generators.'
    },
    
    'HARDCODED_SECRETS': {
        'patterns': {
            'py': [
                r'password\s*=\s*["\'][^"\']{8,}["\']',
                r'api_key\s*=\s*["\'][^"\']+["\']',
                r'secret\s*=\s*["\'][^"\']+["\']',
                r'token\s*=\s*["\'][^"\']+["\']',
                r'AWS_SECRET_ACCESS_KEY\s*=',
            ],
            'js': [
                r'password\s*[:=]\s*["\'][^"\']{8,}["\']',
                r'apiKey\s*[:=]\s*["\'][^"\']+["\']',
                r'secret\s*[:=]\s*["\'][^"\']+["\']',
                r'token\s*[:=]\s*["\'][^"\']+["\']',
            ],
            'java': [
                r'password\s*=\s*"[^"]{8,}"',
                r'apiKey\s*=\s*"[^"]+"',
                r'SECRET_KEY\s*=\s*"[^"]+"',
            ]
        },
        'description': 'Hardcoded credentials or secrets found in code.',
        'severity': 'HIGH',
        'recommendation': 'Store secrets in environment variables or secure vaults. Never commit credentials to version control.'
    },
    
    'UNSAFE_FILE_OPERATIONS': {
        'patterns': {
            'py': [
                r'os\.remove\s*\(\s*(?![\'"]).+(?:filename|filepath|file|path)',  # os.remove with variable
                r'os\.remove\s*\([^)]*request',
                r'os\.unlink\s*\([^)]*request',
                r'shutil\.rmtree\s*\([^)]*request',
                r'os\.chmod\s*\([^)]*0o777',
            ],
            'js': [
                r'fs\.unlink\s*\([^)]*req\.',
                r'fs\.rmdir\s*\([^)]*req\.',
                r'fs\.chmod\s*\([^)]*0o777',
            ],
            'java': [
                r'\.delete\s*\([^)]*request',
                r'Files\.delete\s*\([^)]*request',
            ]
        },
        'description': 'Unsafe file operations. File deletion or permission changes with user input.',
        'severity': 'MEDIUM',
        'recommendation': 'Validate file paths and operations. Implement proper access controls.'
    },
}


def detect_language(filename: str) -> str:
    """Detect programming language from filename"""
    ext = filename.split('.')[-1].lower()
    lang_map = {
        'py': 'py',
        'js': 'js',
        'ts': 'js',
        'jsx': 'js',
        'tsx': 'js',
        'java': 'java',
    }
    return lang_map.get(ext, 'unknown')


def detect_vulnerabilities(code: str, filename: str) -> List[Dict]:
    """
    Detect specific vulnerabilities with line numbers
    
    Returns:
        List of vulnerability dictionaries containing:
        - type: vulnerability type
        - line: line number (1-indexed)
        - code: actual code line
        - description: vulnerability description
        - severity: HIGH, MEDIUM, LOW, CRITICAL
        - recommendation: fix recommendation
    """
    vulnerabilities = []
    language = detect_language(filename)
    
    if language == 'unknown':
        return vulnerabilities
    
    lines = code.split('\n')
    
    # Check each vulnerability pattern
    for vuln_type, vuln_data in VULNERABILITY_PATTERNS.items():
        patterns = vuln_data['patterns'].get(language, [])
        
        for line_num, line in enumerate(lines, start=1):
            # Skip comments
            line_stripped = line.strip()
            if not line_stripped:
                continue
            
            # Python comments
            if language == 'py' and (line_stripped.startswith('#') or '"""' in line_stripped or "'''" in line_stripped):
                continue
            
            # JS/Java comments
            if language in ['js', 'java'] and (line_stripped.startswith('//') or line_stripped.startswith('/*')):
                continue
            
            # Check patterns
            for pattern in patterns:
                if re.search(pattern, line, re.IGNORECASE):
                    vulnerabilities.append({
                        'type': vuln_type,
                        'line': line_num,
                        'code': line.strip(),
                        'description': vuln_data['description'],
                        'severity': vuln_data['severity'],
                        'recommendation': vuln_data['recommendation'],
                        'pattern_matched': pattern
                    })
                    break  # Only report once per line
    
    return vulnerabilities


def get_vulnerability_summary(vulnerabilities: List[Dict]) -> Dict:
    """Generate summary statistics of detected vulnerabilities"""
    if not vulnerabilities:
        return {
            'total': 0,
            'by_severity': {},
            'by_type': {}
        }
    
    severity_count = {}
    type_count = {}
    
    for vuln in vulnerabilities:
        # Count by severity
        severity = vuln['severity']
        severity_count[severity] = severity_count.get(severity, 0) + 1
        
        # Count by type
        vuln_type = vuln['type']
        type_count[vuln_type] = type_count.get(vuln_type, 0) + 1
    
    return {
        'total': len(vulnerabilities),
        'by_severity': severity_count,
        'by_type': type_count
    }


def format_vulnerability_report(vulnerabilities: List[Dict], filename: str) -> str:
    """Format vulnerabilities as human-readable report"""
    if not vulnerabilities:
        return f"\n[+] No vulnerabilities detected in {filename}\n"
    
    report = f"\n[!] VULNERABILITIES FOUND IN: {filename}\n"
    report += "=" * 80 + "\n\n"
    
    # Group by severity
    by_severity = {}
    for vuln in vulnerabilities:
        severity = vuln['severity']
        if severity not in by_severity:
            by_severity[severity] = []
        by_severity[severity].append(vuln)
    
    # Display in severity order
    severity_order = ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW']
    severity_icons = {
        'CRITICAL': '[CRITICAL]',
        'HIGH': '[HIGH]',
        'MEDIUM': '[MEDIUM]',
        'LOW': '[LOW]'
    }
    
    for severity in severity_order:
        if severity not in by_severity:
            continue
        
        icon = severity_icons.get(severity, '[!]')
        report += f"\n{icon} {severity} SEVERITY ({len(by_severity[severity])} found)\n"
        report += "-" * 80 + "\n"
        
        for vuln in by_severity[severity]:
            report += f"\nType: {vuln['type']}\n"
            report += f"Line: {vuln['line']}\n"
            report += f"Code: {vuln['code']}\n"
            report += f"Issue: {vuln['description']}\n"
            report += f"Fix: {vuln['recommendation']}\n"
    
    summary = get_vulnerability_summary(vulnerabilities)
    report += "\n" + "=" * 80 + "\n"
    report += f"SUMMARY: {summary['total']} total vulnerabilities found\n"
    report += f"Severity breakdown: {summary['by_severity']}\n"
    report += "=" * 80 + "\n"
    
    return report
